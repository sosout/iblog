---
title: 正则表达式开发指南
date: 2018-08-10 21:30:47
tags:
    - regex
categories:
    - regex
---

正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。
许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有regexp、regex，复数有regexps、regexes、regexen。

## 使用技巧

### exec() 方法

#### 定义和用法

exec() 方法用于检索字符串中的正则表达式的匹配。

#### 语法

``` js
// string: 必需。要检索的字符串。
RegExpObject.exec(string);
```

#### 返回值

返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。

#### 说明

exec() 方法的功能非常强大，它是一个通用的方法，而且使用起来也比 test() 方法以及支持正则表达式的 String 对象的方法更为复杂。

如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。我们可以看得出，在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。

但是，当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。

#### 提示和注释

重要事项：如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须手动地把 lastIndex 属性重置为 0。

提示：请注意，无论 RegExpObject 是否是全局模式，exec() 都会把完整的细节添加到它返回的数组中。这就是 exec() 与 String.match() 的不同之处，后者在全局模式下返回的信息要少得多。因此我们可以这么说，在循环中反复地调用 exec() 方法是唯一一种获得全局模式的完整模式匹配信息的方法。

### ()和$1...$9的理解和使用

()就是起到一个分组作用，将匹配到的放到mathches集合中，$相当于集合名字，1-9就相当于索引，$1...$9相当于对应索引的值。

**示例一**
```js
// 将yyyy-MM-dd格式的日期转换为yyyy年MM月dd日
const str = "2018-07-02";
const reg =/(\d{4})\-(\d{2})\-(\d{2})/;
const date = str.replace(reg,"$1年$2月$3日");
console.log(date); // "2018年07月02日"
```

**示例二**
```js
// 将yyyy-MM-dd格式的日期转换为yyyy/MM/dd/
const str = "2018-07-02";
const reg =/(\d{4})\-(\d{2})\-(\d{2})/;
const date = str.replace(reg,"$1/$2/$3");
console.log(date); // "2018/07/02"
```

### ^在[]里面和在[]外面如何区分

**^在[]里面**
``` js
/[^0-9]/.test('abc') // true
/[^0-9]/.test('123') // false
``` 
归纳：^在[]里面代表是非数字，所以它代表是非。

**^在[]外面**
``` js
/^[0-9]/.test('abc') // false
/^[0-9]/.test('1bc') // true
```
归纳：^在[]外面代表是为首的数字，所以它代表头。

^在[]里面和在[]外面有一个记忆的方法：乌龟把头(^)缩进里面，变为无（非)头乌龟，乌龟把头(^)伸出来，变为头(首）领。



